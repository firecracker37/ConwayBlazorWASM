<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Conway's Game of Life</title>
    <base href="/" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
    <link href="/css/app.css" rel="stylesheet" />

    <link href="ConwayClient.styles.css" rel="stylesheet" />
</head>

<body>
    <div id="app">
        <div id="loading-container">
            <div>
                <h1>Conway's Game of Life</h1>
                <div id="loading-square"></div>
                <h3>Loading...</h3>
            </div>
        </div>
    </div>

    <div id="blazor-error-ui">
        An unhandled error has occurred.
        <a href="" class="reload">Reload</a>
        <a class="dismiss">ðŸ—™</a>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <script src="/_content/Blazor.Extensions.Canvas/blazor.extensions.canvas.js"></script>
    <script src="/_framework/blazor.webassembly.js"></script>

    <script>
        window.requestAnimationLoop = (dotnetHelper) => {
            const loop = () => {
                dotnetHelper.invokeMethodAsync('Render');
                requestAnimationFrame(loop);
            };
            loop();
        };

        window.addCanvasClickListener = (dotnetHelper) => {
            const canvas = document.querySelector('canvas');
            if (canvas) {
                canvas.addEventListener('click', (event) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;
                    dotnetHelper.invokeMethodAsync('CanvasClicked', x, y);
                });
            }
        };

        window.drawGridOnOffscreenCanvas = (offscreenCanvas, cellWidth, cellHeight, canvasWidth, canvasHeight) => {
            const ctx = offscreenCanvas.getContext('2d');
            ctx.strokeStyle = 'white';
            ctx.beginPath();

            // Draw vertical lines
            for (let x = 0; x <= canvasWidth; x += cellWidth) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvasHeight);
            }

            // Draw horizontal lines
            for (let y = 0; y <= canvasHeight; y += cellHeight) {
                ctx.moveTo(0, y);
                ctx.lineTo(canvasWidth, y);
            }

            ctx.stroke();
        };

        window.createBufferCanvas = (width, height) => {
            const bufferCanvas = new OffscreenCanvas(width, height);
            return bufferCanvas;
        };

        window.transferGridContent = () => {
            var canvases = document.querySelectorAll('canvas');
            if (canvases.length < 3) {
                console.error('Expected at least three canvas elements but found ' + canvases.length);
                return;
            }

            var mainCanvas = canvases[0];
            var gridCanvas = canvases[1]; // Canvas for grid lines
            var mainContext = mainCanvas.getContext('2d');

            // Transfer grid lines
            mainContext.drawImage(gridCanvas, 0, 0);
        };

        window.transferBufferContent = () => {
            var canvases = document.querySelectorAll('canvas');
            if (canvases.length < 3) {
                console.error('Expected at least three canvas elements but found ' + canvases.length);
                return;
            }

            var mainCanvas = canvases[0];
            var bufferCanvas = canvases[2]; // Canvas for buffering game state
            var mainContext = mainCanvas.getContext('2d');

            // Transfer game state from buffer canvas
            mainContext.drawImage(bufferCanvas, 0, 0);
        };
    </script>

</body>

</html>
