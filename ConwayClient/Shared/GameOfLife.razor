@using Blazor.Extensions.Canvas.Canvas2D
@using Blazor.Extensions;
@using Blazor.Extensions.Canvas;
@using ConwayClient.Models;
@using ConwayClient.Utils;
@using System.Diagnostics;
@using System.Collections;

@inject IJSRuntime JSRuntime

<div class="row">
    <div class="col s12">
        <div class="card-panel blue-grey darken-3">
            <div class="row">
                <div class="col s2 center-align">
                    <button @onclick="StartGame" class="btn" disabled="@IsGameRunning">Start</button>
                </div>
                <div class="col s2 center-align">
                    <button @onclick="PauseGame" class="btn" disabled="@( ! IsGameRunning)">Pause</button>
                </div>

                <div class="col s2 center-align">
                    <buton @onclick="ResetGame" class="btn" disabled="@IsGameRunning">Reset</buton>
                </div>
                <div class="col s2 center-align">
                    <buton @onclick="RandomizeBoard" class="btn" disabled="@IsGameRunning">Randomize</buton>
                </div>
                <div class="col s2 center-align">
                    <button @onclick="Undo" class="btn" disabled="@ShouldDisableUndoButton()">Undo</button>
                </div>
                <div class="col s2 center-align">
                    <button class="btn" disabled="true">Btn</button>
                </div>
            </div>
            <div class="row">
                <div class="col s12 center-align">
                    <h5>Game State</h5>
                    <textarea id="gameStateInput" rows="4" cols="50" @bind="gameState"></textarea>
                    <br />
                    <button @onclick="SaveState" class="btn">Save State</button>
                    <button @onclick="LoadState" class="btn">Load State</button>
                </div>
            </div>
        </div>
    </div>
</div>
<div class="row">
    <div class="col s12 center-align">
        <BECanvas Width="@CanvasWidth" Height="@CanvasHeight" @ref="_canvasReference"></BECanvas>
        <div style="display: none;">
            <BECanvas Width="@CanvasWidth" Height="@CanvasHeight" @ref="_offscreenCanvasReference"></BECanvas>
            <BECanvas Width="@CanvasWidth" Height="@CanvasHeight" @ref="_bufferCanvasReference"></BECanvas>
        </div>
    </div>
</div>

@code {
    private Canvas2DContext _context;
    protected BECanvasComponent _canvasReference;
    private Canvas2DContext _offscreenContext;
    protected BECanvasComponent _offscreenCanvasReference;
    private Canvas2DContext _bufferContext;
    protected BECanvasComponent _bufferCanvasReference;
    private GameBoard _gameBoard;
    private DotNetObjectReference<GameOfLife> _objectReference;
    private Timer _gameTimer;

    private const int CanvasWidth = 768;
    private const int CanvasHeight = 768;

    private bool _isGameRunning = false;
    public bool IsGameRunning => _isGameRunning;

    public int Rows { get; set; } = 128;
    public int Columns { get; set; } = 128;

    private int CellWidth => CanvasWidth / Columns;
    private int CellHeight => CanvasHeight / Rows;

    private List<Cell> _updatedCells = new List<Cell>();

    private string gameState;

    private DateTime _lastFrameTime;
    private const double DesiredFrameTime = 1.0 / 144.0;  // For 144 FPS


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _objectReference = DotNetObjectReference.Create(this);

            _gameBoard = new GameBoard(Rows, Columns);
            _context = await _canvasReference.CreateCanvas2DAsync();

            // Initialize the offscreen canvas and draw grid lines on it
            _offscreenContext = await _offscreenCanvasReference.CreateCanvas2DAsync();
            await DrawGridLines(_offscreenContext, CanvasWidth, CanvasHeight, CellWidth, CellHeight);

            // Initialize the buffer canvas
            _bufferContext = await _bufferCanvasReference.CreateCanvas2DAsync();
            await _bufferContext.ClearRectAsync(0, 0, CanvasWidth, CanvasHeight);

            // Start the continuous rendering loop
            await JSRuntime.InvokeVoidAsync("requestAnimationLoop", _objectReference);

            // Add canvas click listener
            await JSRuntime.InvokeVoidAsync("addCanvasClickListener", _objectReference);
        }
    }

    private async Task DrawGridLines(Canvas2DContext context, int canvasWidth, int canvasHeight, int cellWidth, int cellHeight)
    {
        await context.BeginBatchAsync();
        await context.SetStrokeStyleAsync("white");

        // Drawing horizontal lines
        for (int y = 0; y <= canvasHeight; y += cellHeight)
        {
            await context.BeginPathAsync();
            await context.MoveToAsync(0, y);
            await context.LineToAsync(canvasWidth, y);
            await context.StrokeAsync();
        }

        // Drawing vertical lines
        for (int x = 0; x <= canvasWidth; x += cellWidth)
        {
            await context.BeginPathAsync();
            await context.MoveToAsync(x, 0);
            await context.LineToAsync(x, canvasHeight);
            await context.StrokeAsync();
        }

        await context.EndBatchAsync();
    }

    private async Task DrawGameBoard()
    {
        if (_gameBoard == null) return;
        var currentTime = DateTime.UtcNow;
        var timeSinceLastFrame = (currentTime - _lastFrameTime).TotalSeconds;
        if (timeSinceLastFrame < DesiredFrameTime) return;

        var watch = Stopwatch.StartNew();

        // Fill the main canvas with the dead cell color
        await _context.SetFillStyleAsync("#b0bec5");
        await _context.FillRectAsync(0, 0, CanvasWidth, CanvasHeight);

        // Transfer content from offscreen canvas (grid) to main canvas
        if (!IsGameRunning) await JSRuntime.InvokeVoidAsync("transferGridContent");

        // Draw only the updated cells on the buffer canvas
        await _bufferContext.BeginBatchAsync();

        var updatedCells = _gameBoard.GetUpdatedCells();

        // Draw all alive cells
        await _bufferContext.SetFillStyleAsync("#ff8f00"); // Alive cell color
        foreach (var cell in updatedCells.Where(c => c.IsAlive))
        {
            await _bufferContext.FillRectAsync(cell.Column * CellWidth, cell.Row * CellHeight, CellWidth, CellHeight);
        }

        // Clear all newly dead cells
        foreach (var cell in updatedCells.Where(c => !c.IsAlive))
        {
            await _bufferContext.ClearRectAsync(cell.Column * CellWidth, cell.Row * CellHeight, CellWidth, CellHeight);
        }

        await _bufferContext.EndBatchAsync();

        // Transfer content from buffer canvas to main canvas
        await JSRuntime.InvokeVoidAsync("transferBufferContent");

        _gameBoard.ResetIsUpdated();

        watch.Stop();
        var timeSinceLastDraw = (currentTime - _lastFrameTime).TotalSeconds;
        var fps = timeSinceLastDraw > 0 ? 1.0 / timeSinceLastDraw : 0;

        // Display the FPS on the main canvas
        await _context.SetFontAsync("16px sans-serif");
        await _context.SetFillStyleAsync("black");
        await _context.FillTextAsync($"FPS: {fps:F2}", CanvasWidth - 80, 20);
        _lastFrameTime = currentTime;
    }



    [JSInvokable]
    public async Task Render()
    {
        await DrawGameBoard();
    }

    public void StartGame()
    {
        if (_isGameRunning) return;

        _gameTimer = new Timer(_ =>
        {
            _gameBoard.GenerateNextState(); // Directly generate the next game state
        }, null, 0, 500);  // Adjust the interval as needed

        _isGameRunning = true;
    }

    public void PauseGame()
    {
        if (!_isGameRunning) return;

        _gameTimer?.Dispose();
        _gameTimer = null;

        _isGameRunning = false;
    }

    public void Undo()
    {
        if (!IsGameRunning && _gameBoard.CanUndo())
        {
            _gameBoard.UndoLastState();
        }
    }

    private bool ShouldDisableUndoButton()
    {
        if (_gameBoard == null)
            return true;

        return IsGameRunning || !_gameBoard.CanUndo();
    }

    [JSInvokable]
    public void CanvasClicked(double x, double y)
    {
        if (IsGameRunning) return;

        int col = (int)x / CellWidth;
        int row = (int)y / CellHeight;

        if (row >= 0 && row < Rows && col >= 0 && col < Columns)
        {
            _gameBoard.ToggleCellState(row, col);
        }
    }

    public void ResetGame()
    {
        _gameBoard.ResetGame();
    }

    public void RandomizeBoard()
    {
        _gameBoard.RandomizeBoard();
    }

    private BitArray ConvertStateToBitArray(GameBoard gameBoard)
    {
        BitArray bits = new BitArray(gameBoard.Rows * gameBoard.Columns);

        int index = 0;
        for (int row = 0; row < gameBoard.Rows; row++)
        {
            for (int col = 0; col < gameBoard.Columns; col++)
            {
                bits[index++] = gameBoard.GetCellState(row, col);
            }
        }

        return bits;
    }

    private void SetStateFromBitArray(GameBoard gameBoard, BitArray bits)
    {
        if (bits.Length != gameBoard.Rows * gameBoard.Columns)
        {
            throw new ArgumentException("BitArray size doesn't match GameBoard size.");
        }

        int index = 0;
        for (int row = 0; row < gameBoard.Rows; row++)
        {
            for (int col = 0; col < gameBoard.Columns; col++)
            {
                gameBoard.SetCellState(row, col, bits[index++]);
            }
        }
    }

    public static string BitArrayToBase64(BitArray bits)
    {
        byte[] bytes = new byte[(bits.Length + 7) / 8];
        bits.CopyTo(bytes, 0);
        return Convert.ToBase64String(bytes);
    }

    public static BitArray Base64ToBitArray(string base64)
    {
        byte[] bytes = Convert.FromBase64String(base64);
        return new BitArray(bytes);
    }

    private void SaveState()
    {
        /// Convert the game board's state to a BitArray
        BitArray bitArray = ConvertStateToBitArray(_gameBoard);

        // Convert the BitArray to a byte array
        byte[] byteArray = ZipUtil.BitArrayToByteArray(bitArray);

        // Compress the byte array
        byte[] compressedByteArray = ZipUtil.Compress(byteArray);

        // Convert the compressed byte array to a Base64 string for sharing
        gameState = Convert.ToBase64String(compressedByteArray);
    }

    private void LoadState()
    {
        // Get the gameState from the textarea

        // Decode the Base64 string to a byte array
        byte[] compressedBytes = Convert.FromBase64String(gameState);

        // Decompress the byte array
        byte[] decompressedBytes = ZipUtil.Decompress(compressedBytes);

        // Convert the byte array back to a BitArray
        BitArray bitArray = new BitArray(decompressedBytes);

        // Convert the BitArray back to your game board's state
        SetStateFromBitArray(_gameBoard, bitArray);
    }

    public void Dispose()
    {
        _gameTimer?.Dispose();
        _objectReference?.Dispose();
    }
}