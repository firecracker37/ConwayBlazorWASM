@using Blazor.Extensions.Canvas.Canvas2D
@using Blazor.Extensions;
@using Blazor.Extensions.Canvas;
@using ConwayClient.Models;
@using System.Diagnostics;

@inject IJSRuntime JSRuntime

<div class="row">
    <div class="col s12">
        <div class="card-panel blue-grey darken-3">
            <div class="row">
                <div class="col s3 center-align">
                    <button @onclick="StartGame" class="btn" disabled="@IsGameRunning">Start</button>
                </div>
                <div class="col s3 center-align">
                    <button @onclick="PauseGame" class="btn" disabled="@( ! IsGameRunning)">Pause</button>
                </div>

                <div class="col s3 center-align">
                    <buton @onclick="ResetGame" class="btn" disabled="@IsGameRunning">Reset</buton>
                </div>
                <div class="col s3 center-align">
                    <buton @onclick="RandomizeBoard" class="btn" disabled="@IsGameRunning">Randomize</buton>
                </div>
            </div>
        </div>
    </div>
</div>
<div class="row">
    <div class="col s12 center-align">
        <BECanvas Width="@CanvasWidth" Height="@CanvasHeight" @ref="_canvasReference"></BECanvas>
        <div style="display: none;">
            <BECanvas Width="@CanvasWidth" Height="@CanvasHeight" @ref="_offscreenCanvasReference"></BECanvas>
            <BECanvas Width="@CanvasWidth" Height="@CanvasHeight" @ref="_bufferCanvasReference"></BECanvas>
        </div>
    </div>
</div>

@code {
    private Canvas2DContext _context;
    protected BECanvasComponent _canvasReference;
    private Canvas2DContext _offscreenContext;
    protected BECanvasComponent _offscreenCanvasReference;
    private Canvas2DContext _bufferContext;
    protected BECanvasComponent _bufferCanvasReference;
    private GameBoard _gameBoard;
    private DotNetObjectReference<GameOfLife> _objectReference;
    private Timer _gameTimer;

    private const int CanvasWidth = 768;
    private const int CanvasHeight = 768;

    public bool IsGameRunning => _gameBoard?.IsRunning ?? false;

    public int Rows { get; set; } = 128;
    public int Columns { get; set; } = 128;

    private int CellWidth => CanvasWidth / Columns;
    private int CellHeight => CanvasHeight / Rows;

    private List<Cell> _updatedCells = new List<Cell>();

    private DateTime _lastFrameTime;
    private const double DesiredFrameTime = 1.0 / 144.0;  // For 144 FPS


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _objectReference = DotNetObjectReference.Create(this);

            _gameBoard = new GameBoard(Rows, Columns);
            _context = await _canvasReference.CreateCanvas2DAsync();

            // Initialize the offscreen canvas and draw grid lines on it
            _offscreenContext = await _offscreenCanvasReference.CreateCanvas2DAsync();
            await DrawGridLines(_offscreenContext, CanvasWidth, CanvasHeight, CellWidth, CellHeight);

            // Initialize the buffer canvas
            _bufferContext = await _bufferCanvasReference.CreateCanvas2DAsync();
            await _bufferContext.ClearRectAsync(0, 0, CanvasWidth, CanvasHeight);

            // Start the continuous rendering loop
            await JSRuntime.InvokeVoidAsync("requestAnimationLoop", _objectReference);

            // Add canvas click listener
            await JSRuntime.InvokeVoidAsync("addCanvasClickListener", _objectReference);
        }
    }

    private async Task DrawGridLines(Canvas2DContext context, int canvasWidth, int canvasHeight, int cellWidth, int cellHeight)
    {
        await context.BeginBatchAsync();
        await context.SetStrokeStyleAsync("white");

        // Drawing horizontal lines
        for (int y = 0; y <= canvasHeight; y += cellHeight)
        {
            await context.BeginPathAsync();
            await context.MoveToAsync(0, y);
            await context.LineToAsync(canvasWidth, y);
            await context.StrokeAsync();
        }

        // Drawing vertical lines
        for (int x = 0; x <= canvasWidth; x += cellWidth)
        {
            await context.BeginPathAsync();
            await context.MoveToAsync(x, 0);
            await context.LineToAsync(x, canvasHeight);
            await context.StrokeAsync();
        }

        await context.EndBatchAsync();
    }

    private async Task DrawGameBoard()
    {
        if (_gameBoard == null) return;
        var currentTime = DateTime.UtcNow;
        var timeSinceLastFrame = (currentTime - _lastFrameTime).TotalSeconds;
        if (timeSinceLastFrame < DesiredFrameTime) return;

        var watch = Stopwatch.StartNew();

        // Fill the main canvas with the dead cell color
        await _context.SetFillStyleAsync("#b0bec5");
        await _context.FillRectAsync(0, 0, CanvasWidth, CanvasHeight);

        // Transfer content from offscreen canvas (grid) to main canvas
        if (!IsGameRunning) await JSRuntime.InvokeVoidAsync("transferGridContent");

        // Draw only the updated cells on the buffer canvas
        await _bufferContext.BeginBatchAsync();

        var updatedCells = _gameBoard.GetUpdatedCells();

        // Draw all alive cells
        await _bufferContext.SetFillStyleAsync("#ff8f00"); // Alive cell color
        foreach (var cell in updatedCells.Where(c => c.IsAlive))
        {
            await _bufferContext.FillRectAsync(cell.Column * CellWidth, cell.Row * CellHeight, CellWidth, CellHeight);
        }

        // Clear all newly dead cells
        foreach (var cell in updatedCells.Where(c => !c.IsAlive))
        {
            await _bufferContext.ClearRectAsync(cell.Column * CellWidth, cell.Row * CellHeight, CellWidth, CellHeight);
        }

        await _bufferContext.EndBatchAsync();

        // Transfer content from buffer canvas to main canvas
        await JSRuntime.InvokeVoidAsync("transferBufferContent");

        _gameBoard.ResetIsUpdated();

        watch.Stop();
        var timeSinceLastDraw = (currentTime - _lastFrameTime).TotalSeconds;
        var fps = timeSinceLastDraw > 0 ? 1.0 / timeSinceLastDraw : 0;

        // Display the FPS on the main canvas
        await _context.SetFontAsync("16px sans-serif");
        await _context.SetFillStyleAsync("black");
        await _context.FillTextAsync($"FPS: {fps:F2}", CanvasWidth - 80, 20);
        _lastFrameTime = currentTime;
    }



    [JSInvokable]
    public async Task Render()
    {
        await DrawGameBoard();
    }

    public void StartGame()
    {
        if (_gameBoard.IsRunning) return;
        _gameBoard.StartGame();
        _gameTimer = new Timer(_ =>
        {
            _gameBoard.GenerateNextState(); // Directly generate the next game state
        }, null, 0, 500);  // Adjust the interval as needed
    }

    public void PauseGame()
    {
        if (!_gameBoard.IsRunning) return;

        _gameTimer?.Dispose();
        _gameTimer = null;
        _gameBoard.PauseGame();
    }

    [JSInvokable]
    public void CanvasClicked(double x, double y)
    {
        if (IsGameRunning) return;

        int col = (int)x / CellWidth;
        int row = (int)y / CellHeight;

        if (row >= 0 && row < Rows && col >= 0 && col < Columns)
        {
            _gameBoard.ToggleCellState(row, col);
        }
    }

    public void ResetGame()
    {
        _gameBoard.ResetGame();
    }

    public void RandomizeBoard()
    {
        _gameBoard.RandomizeBoard();
    }

    public void Dispose()
    {
        _gameTimer?.Dispose();
        _objectReference?.Dispose();
    }
}