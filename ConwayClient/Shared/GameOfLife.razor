@using Blazor.Extensions.Canvas.Canvas2D
@using Blazor.Extensions;
@using ConwayClient.Models;

@inject IJSRuntime JSRuntime

<div class="row">
    <div class="col s12 center-align">
        <BECanvas Width="@CanvasWidth" Height="@CanvasHeight" @ref="_canvasReference"></BECanvas>
    </div>
</div>

@code {
    private Canvas2DContext _context;
    protected BECanvasComponent _canvasReference;
    private GameBoard _gameBoard;
    private DotNetObjectReference<GameOfLife> _objectReference;
    private Timer _gameTimer;

    private const int CanvasWidth = 960;
    private const int CanvasHeight = 540;

    public bool IsGameRunning => _gameBoard.IsRunning;

    [Parameter] public int Rows { get; set; } = 9;
    [Parameter] public int Columns { get; set; } = 16;
    [Parameter] public EventCallback<bool> OnGameStateChanged { get; set; }

    private int CellWidth => CanvasWidth / Columns;
    private int CellHeight => CanvasHeight / Rows;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _objectReference = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("addCanvasClickListener", _objectReference);
            _gameBoard = new GameBoard(Rows, Columns);
            _context = await _canvasReference.CreateCanvas2DAsync();
            await DrawGameBoard();
        }
    }

    private async Task DrawGameBoard()
    {
        if (_gameBoard.IsUpdating) return;

        for (int row = 0; row < _gameBoard.Rows; row++)
        {
            for (int col = 0; col < _gameBoard.Columns; col++)
            {
                Cell cell = _gameBoard.Cells[row, col];
                string fillColor = cell.IsAlive ? "#ff8f00" : "#b0bec5";

                await _context.SetFillStyleAsync(fillColor);
                await _context.FillRectAsync(col * CellWidth, row * CellHeight, CellWidth, CellHeight);
                await _context.SetStrokeStyleAsync("white");
                await _context.StrokeRectAsync(col * CellWidth, row * CellHeight, CellWidth, CellHeight);
            }
        }
    }

    private async Task DrawGameBoard(IEnumerable<Cell> changedCells)
    {
        if (_gameBoard.IsUpdating) return;

        foreach (var cell in changedCells)
        {
            //Console.WriteLine($"Drawing Cell at ({cell.X}, {cell.Y}) with state {cell.IsAlive}");

            string fillColor = cell.IsAlive ? "#ff8f00" : "#b0bec5";

            await _context.SetFillStyleAsync(fillColor);
            await _context.FillRectAsync(cell.Y * CellWidth, cell.X * CellHeight, CellWidth, CellHeight);
            await _context.SetStrokeStyleAsync("white");
            await _context.StrokeRectAsync(cell.Y * CellWidth, cell.X * CellHeight, CellWidth, CellHeight);
        }
    }

    public async Task StartGame()
    {
        if (_gameBoard.IsRunning) return;
        _gameBoard.StartGame();
        _gameTimer = new Timer(async _ =>
        {
            var nextState = _gameBoard.GenerateNextState(); // Generate the next game state
            await _gameBoard.UpdateGameStateAsync(nextState); // Update the game state with the next state
            await InvokeAsync(() => DrawGameBoard());
        }, null, 0, 500);  // Adjust the interval as needed

        await OnGameStateChanged.InvokeAsync(_gameBoard.IsRunning);
    }



    public async Task PauseGame()
    {
        if (!_gameBoard.IsRunning) return;

        await _gameBoard.StartUpdateAsync();  // This will wait for ongoing updates to finish
        _gameBoard.FinishUpdate();  // Release the semaphore immediately after acquiring it

        _gameTimer?.Dispose();
        _gameTimer = null;
        _gameBoard.PauseGame();

        await OnGameStateChanged.InvokeAsync(_gameBoard.IsRunning);
    }

    public async Task ToggleCellState(int row, int col)
    {
        // Create a copy of the current state
        var toggledState = (Cell[,])_gameBoard.Cells.Clone();

        // Toggle the cell's state in the copied state
        toggledState[row, col].IsAlive = !toggledState[row, col].IsAlive;

        // Update the game state with the toggled state
        await _gameBoard.UpdateGameStateAsync(toggledState);

        // Redraw the game board
        await DrawGameBoard();
    }

    [JSInvokable]
    public async Task CanvasClicked(double x, double y)
    {
        int col = (int)x / CellWidth;
        int row = (int)y / CellHeight;

        if (row >= 0 && row < Rows && col >= 0 && col < Columns)
        {
            await ToggleCellState(row, col);
        }
    }

    public async Task ResetGame()
    {
        await _gameBoard.ResetGame();
        await DrawGameBoard();
    }

    public async Task RandomizeBoard()
    {
        await _gameBoard.RandomizeBoard();
        await DrawGameBoard();
    }

    public void Dispose()
    {
        _gameTimer?.Dispose();
        _objectReference?.Dispose();
    }
}