@using Blazor.Extensions.Canvas.Canvas2D
@using Blazor.Extensions;
@using Blazor.Extensions.Canvas;
@using ConwayClient.Models;
@using System.Diagnostics;

@inject IJSRuntime JSRuntime

<div class="row">
    <div class="col s12">
        <div class="card-panel blue-grey darken-3">
            <div class="row">
                <div class="col s3 center-align">
                    <button @onclick="StartGame" class="btn" disabled="@IsGameRunning">Start</button>
                </div>
                <div class="col s3 center-align">
                    <button @onclick="PauseGame" class="btn" disabled="@( ! IsGameRunning)">Pause</button>
                </div>

                <div class="col s3 center-align">
                    <buton @onclick="ResetGame" class="btn" disabled="@IsGameRunning">Reset</buton>
                </div>
                <div class="col s3 center-align">
                    <buton @onclick="RandomizeBoard" class="btn" disabled="@IsGameRunning">Randomize</buton>
                </div>
            </div>
        </div>
    </div>
</div>
<div class="row">
    <div class="col s12 center-align">
        <BECanvas Width="@CanvasWidth" Height="@CanvasHeight" @ref="_canvasReference"></BECanvas>
        <div style="visibility: hidden">
            <BECanvas Width="@CanvasWidth" Height="@CanvasHeight" @ref="_offscreenCanvasReference"></BECanvas>
        </div>
    </div>
</div>

@code {
    private Canvas2DContext _context;
    protected BECanvasComponent _canvasReference;
    private Canvas2DContext _offscreenContext;
    protected BECanvasComponent _offscreenCanvasReference;
    private GameBoard _gameBoard;
    private DotNetObjectReference<GameOfLife> _objectReference;
    private Timer _gameTimer;

    private const int CanvasWidth = 960;
    private const int CanvasHeight = 540;

    public bool IsGameRunning => _gameBoard?.IsRunning ?? false;

    public int Rows { get; set; } = 36;
    public int Columns { get; set; } = 64;

    private int CellWidth => CanvasWidth / Columns;
    private int CellHeight => CanvasHeight / Rows;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _objectReference = DotNetObjectReference.Create(this);

            _gameBoard = new GameBoard(Rows, Columns);
            _context = await _canvasReference.CreateCanvas2DAsync();

            // Initialize the offscreen canvas and draw grid lines on it
            _offscreenContext = await _offscreenCanvasReference.CreateCanvas2DAsync();
            await DrawGridLines(_offscreenContext, CanvasWidth, CanvasHeight, CellWidth, CellHeight);

            // Start the continuous rendering loop
            await JSRuntime.InvokeVoidAsync("requestAnimationLoop", _objectReference);

            // Add canvas click listener
            await JSRuntime.InvokeVoidAsync("addCanvasClickListener", _objectReference);
        }
    }

    private async Task DrawGridLines(Canvas2DContext context, int canvasWidth, int canvasHeight, int cellWidth, int cellHeight)
    {
        await context.BeginBatchAsync();
        await context.SetStrokeStyleAsync("white");

        // Drawing horizontal lines
        for (int y = 0; y <= canvasHeight; y += cellHeight)
        {
            await context.BeginPathAsync();
            await context.MoveToAsync(0, y);
            await context.LineToAsync(canvasWidth, y);
            await context.StrokeAsync();
        }

        // Drawing vertical lines
        for (int x = 0; x <= canvasWidth; x += cellWidth)
        {
            await context.BeginPathAsync();
            await context.MoveToAsync(x, 0);
            await context.LineToAsync(x, canvasHeight);
            await context.StrokeAsync();
        }

        await context.EndBatchAsync();
    }

    private async Task DrawGameBoard()
    {
        if (_gameBoard == null) return;

        var watch = Stopwatch.StartNew();

        // Clear the main canvas with the dead cell color
        await _context.SetFillStyleAsync("#b0bec5");
        await _context.FillRectAsync(0, 0, CanvasWidth, CanvasHeight);

        // Transfer content from offscreen canvas to main canvas
        await JSRuntime.InvokeVoidAsync("transferContent");

        await _context.BeginBatchAsync();  // Begin batched drawing operations

        // Set the fill style for alive cells
        await _context.SetFillStyleAsync("#ff8f00");

        // Draw alive cells
        for (int row = 0; row < _gameBoard.Rows; row++)
        {
            for (int col = 0; col < _gameBoard.Columns; col++)
            {
                if (_gameBoard.Cells[row, col].IsAlive)
                {
                    await _context.FillRectAsync(col * CellWidth, row * CellHeight, CellWidth, CellHeight);
                }
            }
        }

        await _context.EndBatchAsync();  // Execute batched drawing operations

        watch.Stop();
        var frameTime = watch.Elapsed.TotalSeconds;  // time taken to render the frame
        var fps = frameTime > 0 ? 1.0 / frameTime : 0;  // calculate FPS

        // Display the FPS
        await _context.SetFontAsync("16px sans-serif");
        await _context.SetFillStyleAsync("black");
        await _context.FillTextAsync($"FPS: {fps:F2}", CanvasWidth - 80, 20);
    }

    [JSInvokable]
    public async Task Render()
    {
        await DrawGameBoard();
    }

    public void StartGame()
    {
        if (_gameBoard.IsRunning) return;
        _gameBoard.StartGame();
        _gameTimer = new Timer(_ =>
        {
            _gameBoard.GenerateNextState(); // Directly generate the next game state
        }, null, 0, 500);  // Adjust the interval as needed
    }

    public void PauseGame()
    {
        if (!_gameBoard.IsRunning) return;

        _gameTimer?.Dispose();
        _gameTimer = null;
        _gameBoard.PauseGame();
    }

    [JSInvokable]
    public void CanvasClicked(double x, double y)
    {
        int col = (int)x / CellWidth;
        int row = (int)y / CellHeight;

        if (row >= 0 && row < Rows && col >= 0 && col < Columns)
        {
            _gameBoard.ToggleCellState(row, col);
        }
    }

    public void ResetGame()
    {
        _gameBoard.ResetGame();
    }

    public void RandomizeBoard()
    {
        _gameBoard.RandomizeBoard();
    }

    public void Dispose()
    {
        _gameTimer?.Dispose();
        _objectReference?.Dispose();
    }
}