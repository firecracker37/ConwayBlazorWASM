@using Blazor.Extensions.Canvas.Canvas2D
@using Blazor.Extensions;
@using Blazor.Extensions.Canvas;
@using ConwayClient.Models;
@using ConwayClient.Utils;
@using System.Diagnostics;
@using System.Collections;

@inject IJSRuntime JSRuntime

<!-- Row for the entire layout -->
<div class="row grey darken-3">

    <!-- Left column for the configuration panel -->
    <div class="col s12 m4">
        <ConfigurationPanel IsGameRunning="IsGameRunning"
                            ShowGridLines="ShowGridLines"
                            @bind-GameState="gameState"
                            OnResetGame="HandleResetGame"
                            OnRandomizeBoard="HandleRandomizeBoard"
                            OnToggleGridLines="HandleToggleGridLines"
                            OnSaveState="HandleSaveState"
                            OnLoadState="HandleLoadState" />

    </div>


    <!-- Right column for the game board -->
    <div class="col s12 m8 grey darken-4">
        <div class="row">
            <!-- Top Button (Play/Pause) -->
            <div class="col s12 center-align">
                <a class="btn-floating btn-large indigo" @onclick="ToggleGameState">
                    <i id="playPauseIcon" class="large material-icons">@(_isGameRunning ? "pause" : "play_arrow")</i>
                </a>
            </div>
        </div>

        <div class="row valign-wrapper">
            <!-- Left Button (Undo) -->
            <div class="col s2 center-align">
                <a @onclick="Undo" class="btn-floating btn-large indigo" disabled="@ShouldDisableUndoButton()">
                    <i class="large material-icons">skip_previous</i>
                </a>
            </div>

            <!-- Canvas -->
            <div class="col s8 center-align">
                <BECanvas Width="@CanvasWidth" Height="@CanvasHeight" @ref="_canvasReference"></BECanvas>
            </div>

            <!-- Right Button (Next) -->
            <div class="col s2 center-align">
                <a class="btn-floating btn-large indigo" @onclick="GenerateNextState" disabled="@IsGameRunning">
                    <i class="large material-icons">skip_next</i>
                </a>
            </div>
        </div>

        <!-- Hidden Canvases -->
        <div style="display: none;">
            <BECanvas Width="@CanvasWidth" Height="@CanvasHeight" @ref="_offscreenCanvasReference"></BECanvas>
            <BECanvas Width="@CanvasWidth" Height="@CanvasHeight" @ref="_bufferCanvasReference"></BECanvas>
        </div>
    </div>
</div>


@code {
    private Canvas2DContext _context;
    protected BECanvasComponent _canvasReference;
    private Canvas2DContext _offscreenContext;
    protected BECanvasComponent _offscreenCanvasReference;
    private Canvas2DContext _bufferContext;
    protected BECanvasComponent _bufferCanvasReference;
    private GameBoard _gameBoard;
    private DotNetObjectReference<GameOfLife> _objectReference;
    private Timer _gameTimer;

    private const int CanvasWidth = 768;
    private const int CanvasHeight = 768;

    private bool _isGameRunning = false;
    public bool IsGameRunning => _isGameRunning;

    public int Rows { get; set; } = 128;
    public int Columns { get; set; } = 128;

    private int CellWidth => CanvasWidth / Columns;
    private int CellHeight => CanvasHeight / Rows;

    private List<Cell> _updatedCells = new List<Cell>();

    private string gameState;
    private bool ShowGridLines { get; set; } = true;

    private DateTime _lastFrameTime;
    private const double DesiredFrameTime = 1.0 / 144.0;  // For 144 FPS


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _objectReference = DotNetObjectReference.Create(this);

            _gameBoard = new GameBoard(Rows, Columns);
            _context = await _canvasReference.CreateCanvas2DAsync();

            // Initialize the offscreen canvas and draw grid lines on it
            _offscreenContext = await _offscreenCanvasReference.CreateCanvas2DAsync();
            await DrawGridLines(_offscreenContext, CanvasWidth, CanvasHeight, CellWidth, CellHeight);

            // Initialize the buffer canvas
            _bufferContext = await _bufferCanvasReference.CreateCanvas2DAsync();
            await _bufferContext.ClearRectAsync(0, 0, CanvasWidth, CanvasHeight);

            // Start the continuous rendering loop
            await JSRuntime.InvokeVoidAsync("requestAnimationLoop", _objectReference);

            // Add canvas click listener
            await JSRuntime.InvokeVoidAsync("addCanvasClickListener", _objectReference);
        }
    }

    private async Task DrawGridLines(Canvas2DContext context, int canvasWidth, int canvasHeight, int cellWidth, int cellHeight)
    {
        await context.BeginBatchAsync();
        await context.SetStrokeStyleAsync("#bdbdbd");

        // Drawing horizontal lines
        for (int y = 0; y <= canvasHeight; y += cellHeight)
        {
            await context.BeginPathAsync();
            await context.MoveToAsync(0, y);
            await context.LineToAsync(canvasWidth, y);
            await context.StrokeAsync();
        }

        // Drawing vertical lines
        for (int x = 0; x <= canvasWidth; x += cellWidth)
        {
            await context.BeginPathAsync();
            await context.MoveToAsync(x, 0);
            await context.LineToAsync(x, canvasHeight);
            await context.StrokeAsync();
        }

        await context.EndBatchAsync();
    }

    private async Task DrawGameBoard()
    {
        if (_gameBoard == null) return;
        var currentTime = DateTime.UtcNow;
        var timeSinceLastFrame = (currentTime - _lastFrameTime).TotalSeconds;
        if (timeSinceLastFrame < DesiredFrameTime) return;

        var watch = Stopwatch.StartNew();

        // Fill the main canvas with the dead cell color
        await _context.SetFillStyleAsync("#424242");
        await _context.FillRectAsync(0, 0, CanvasWidth, CanvasHeight);

        // Transfer content from offscreen canvas (grid) to main canvas
        if (!IsGameRunning && ShowGridLines) await JSRuntime.InvokeVoidAsync("transferGridContent");

        // Draw only the updated cells on the buffer canvas
        await _bufferContext.BeginBatchAsync();

        var updatedCells = _gameBoard.GetUpdatedCells();

        // Draw all alive cells
        await _bufferContext.SetFillStyleAsync("#1a237e"); // Alive cell color
        foreach (var cell in updatedCells.Where(c => c.IsAlive))
        {
            await _bufferContext.FillRectAsync(cell.Column * CellWidth, cell.Row * CellHeight, CellWidth, CellHeight);
        }

        // Clear all newly dead cells
        foreach (var cell in updatedCells.Where(c => !c.IsAlive))
        {
            await _bufferContext.ClearRectAsync(cell.Column * CellWidth, cell.Row * CellHeight, CellWidth, CellHeight);
        }

        await _bufferContext.EndBatchAsync();

        // Transfer content from buffer canvas to main canvas
        await JSRuntime.InvokeVoidAsync("transferBufferContent");

        _gameBoard.ResetIsUpdated();

        watch.Stop();
        var timeSinceLastDraw = (currentTime - _lastFrameTime).TotalSeconds;
        var fps = timeSinceLastDraw > 0 ? 1.0 / timeSinceLastDraw : 0;

        // Display the FPS on the main canvas
        await _context.SetFontAsync("16px sans-serif");
        await _context.SetFillStyleAsync("black");
        await _context.FillTextAsync($"FPS: {fps:F2}", CanvasWidth - 80, 20);
        _lastFrameTime = currentTime;
    }

    [JSInvokable]
    public async Task Render()
    {
        await DrawGameBoard();
    }

    public void StartGame()
    {
        if (_isGameRunning) return;

        _gameTimer = new Timer(_ =>
        {
            _gameBoard.GenerateNextState(); // Directly generate the next game state
        }, null, 0, 500);  // Adjust the interval as needed

        _isGameRunning = true;
    }

    public void PauseGame()
    {
        if (!_isGameRunning) return;

        _gameTimer?.Dispose();
        _gameTimer = null;

        _isGameRunning = false;
    }

    [JSInvokable]
    public async Task ToggleGameState()
    {
        if (_isGameRunning)
            PauseGame();
        else
            StartGame();

        await JSRuntime.InvokeVoidAsync("togglePlayPauseIcon", _isGameRunning);
    }

    public void GenerateNextState()
    {
        if (!_isGameRunning)
        {
            _gameBoard.GenerateNextState();
        }
    }

    public void Undo()
    {
        if (!IsGameRunning && _gameBoard.CanUndo())
        {
            _gameBoard.UndoLastState();
        }
    }

    private bool ShouldDisableUndoButton()
    {
        if (_gameBoard == null)
            return true;

        return IsGameRunning || !_gameBoard.CanUndo();
    }

    [JSInvokable]
    public void CanvasClicked(double x, double y)
    {
        if (IsGameRunning) return;

        int col = (int)x / CellWidth;
        int row = (int)y / CellHeight;

        if (row >= 0 && row < Rows && col >= 0 && col < Columns)
        {
            _gameBoard.ToggleCellState(row, col);
        }
    }

    public void ResetGame()
    {
        _gameBoard.ResetGame();
    }

    public void RandomizeBoard()
    {
        _gameBoard.RandomizeBoard();
    }

    private BitArray ConvertStateToBitArray(GameBoard gameBoard)
    {
        BitArray bits = new BitArray(gameBoard.Rows * gameBoard.Columns);

        int index = 0;
        for (int row = 0; row < gameBoard.Rows; row++)
        {
            for (int col = 0; col < gameBoard.Columns; col++)
            {
                bits[index++] = gameBoard.GetCellState(row, col);
            }
        }

        return bits;
    }

    private void SetStateFromBitArray(GameBoard gameBoard, BitArray bits)
    {
        if (bits.Length != gameBoard.Rows * gameBoard.Columns)
        {
            throw new ArgumentException("BitArray size doesn't match GameBoard size.");
        }

        int index = 0;
        for (int row = 0; row < gameBoard.Rows; row++)
        {
            for (int col = 0; col < gameBoard.Columns; col++)
            {
                gameBoard.SetCellState(row, col, bits[index++]);
            }
        }
    }

    public static string BitArrayToBase64(BitArray bits)
    {
        byte[] bytes = new byte[(bits.Length + 7) / 8];
        bits.CopyTo(bytes, 0);
        return Convert.ToBase64String(bytes);
    }

    public static BitArray Base64ToBitArray(string base64)
    {
        byte[] bytes = Convert.FromBase64String(base64);
        return new BitArray(bytes);
    }

    private void SaveState()
    {
        /// Convert the game board's state to a BitArray
        BitArray bitArray = ConvertStateToBitArray(_gameBoard);

        // Convert the BitArray to a byte array
        byte[] byteArray = ZipUtil.BitArrayToByteArray(bitArray);

        // Compress the byte array
        byte[] compressedByteArray = ZipUtil.Compress(byteArray);

        // Convert the compressed byte array to a Base64 string for sharing
        gameState = Convert.ToBase64String(compressedByteArray);
    }

    private void LoadState()
    {
        // Get the gameState from the textarea

        // Decode the Base64 string to a byte array
        byte[] compressedBytes = Convert.FromBase64String(gameState);

        // Decompress the byte array
        byte[] decompressedBytes = ZipUtil.Decompress(compressedBytes);

        // Convert the byte array back to a BitArray
        BitArray bitArray = new BitArray(decompressedBytes);

        // Convert the BitArray back to your game board's state
        SetStateFromBitArray(_gameBoard, bitArray);
    }

    [JSInvokable]
    private async Task UpdateTextareaValue(string newValue)
    {
        gameState = newValue;

        await JSRuntime.InvokeVoidAsync("resizeAllMaterializeTextareas");
    }

    public void Dispose()
    {
        _gameTimer?.Dispose();
        _objectReference?.Dispose();
    }

    // Event Handlers for ConfigurationPanel actions
    private void HandleResetGame()
    {
        ResetGame();
    }

    private void HandleRandomizeBoard()
    {
        RandomizeBoard();
    }

    private void HandleToggleGridLines()
    {
        ShowGridLines = !ShowGridLines;
    }

    private void HandleSaveState(string gameState)
    {
        this.gameState = gameState;
        SaveState();
    }

    private void HandleLoadState(string gameState)
    {
        this.gameState = gameState;
        LoadState();
    }

    private void OnGameStateChanged(string newState)
    {
        gameState = newState;
    }
}